[
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/2022-01-04-covid.html",
    "href": "posts/2022-01-04-covid.html",
    "title": "Covid in Japan",
    "section": "",
    "text": "“コロナの新規陽性者数のデータを使った時系列データ分析の練習ノート. 日本のコロナの新規陽性者数のデータを使って統計学基礎 1.7.3節の時系列データの変動分解を試みる. 傾向変動として全国新規陽性者数y_tのデータで7日間移動平均を使ったもの, y_tの対数を取ったデータに対し7日間移動平均をとったもの, y_tの対数を取ったデータを線形回帰したものを使った変動分解を行い結果を考察する.” - toc: false - branch: master - badges: true - comments: true - categories: [julia, covid, statistics] - hide: false - search_exclude: true"
  },
  {
    "objectID": "posts/2022-01-04-covid.html#グラフ所感",
    "href": "posts/2022-01-04-covid.html#グラフ所感",
    "title": "Covid in Japan",
    "section": "3.1 グラフ所感",
    "text": "3.1 グラフ所感\n\n2022/01/04現在では第6波の兆しが見える.\n2022/01/11現在では第6波が確定した."
  },
  {
    "objectID": "posts/2022-01-04-covid.html#raw-dataと7日間移動平均",
    "href": "posts/2022-01-04-covid.html#raw-dataと7日間移動平均",
    "title": "Covid in Japan",
    "section": "4.1 raw dataと7日間移動平均",
    "text": "4.1 raw dataと7日間移動平均\nこのデータからTC_tを分離したい. まずは教科書に倣いTC_tとして移動平均を使ってみる. 日本の検査では休日(日曜)明けの検査では陽性者数が少なく, 木曜に陽性者数が多くでる傾向があることが知られている. そこで7日間の移動平均を取ってみる:\n\n\nCode\ndf.weekly_ave=sma(df.ALL, n=7);\n\n\n\n\nCode\nplot(df.Date, df.weekly_ave, seriestype = :scatter)\n\n\n\n\n\nraw dataから移動平均を引いたものをプロットしてみる:\n\n\nCode\nplot(df.ALL .- df.weekly_ave, seriestype = :scatter)\n\n\n\n\n\n教科書のやり方に倣えば次のステップでは曜日別に平均を取って季節変動を求めるが上記グラフからTC_tとして移動平均を用いるのは適していない. なぜなら傾向変動TC_tは大域的な寄与を表しているはずなのにその影響を除いたy_t-TC_tに山の影響が現れているからである."
  },
  {
    "objectID": "posts/2022-01-04-covid.html#対数とその7日間移動平均",
    "href": "posts/2022-01-04-covid.html#対数とその7日間移動平均",
    "title": "Covid in Japan",
    "section": "4.2 対数とその7日間移動平均",
    "text": "4.2 対数とその7日間移動平均\n感染症は指数的に増減することが知られているので対数をとってプロットしてみる. データには新規陽性者数が0の日があり対数をとる際に不便なので微小な数\\epsilonを加えて回避する.\n\n\nCode\nϵ = 0.0000001;\n\n\n\n\nCode\ndf.log_all=log.(df.ALL .+ ϵ);\n\n\n\n\nCode\nplot(df.Date, df.log_all, seriestype = :scatter)\n\n\n\n\n\n対数をとってみると第6波の兆候がよりはっきり確認できる.\n対数の世界で移動平均を取り対数化したデータとの差分を見てみる:\n\n\nCode\ndf.log_weekly_ave = sma(df.log_all, n=7);\ndf.log_diff = df.log_all .- df.log_weekly_ave;\n\n\n\n\nCode\nplot((df.log_diff )[40:end], seriestype = :scatter)\n\n\n\n\n\n対数の世界では移動平均からの差分が大体-1.5~1の間に収まりピークの影響を受けづらくなったことがわかる. ここで最初の39日分は陽性者数が0のデータの影響を受け変動が激しいため捨てた. まだ若干の傾向があるようにも見えるが取り敢えず次に進む.\n次は季節変動S_tを計算したい. 上記の図からは曜日別の変動が目視では確認しずらいが曜日別の平均をとって季節変動S計算してみる.\n\n\nCode\nsum_n=zeros(7)\ncount_day_of_week=zeros(Int,7)\nfor (i, n) in enumerate((df.log_diff )[40:end])\n    sum_n[i%7+1]+=n\n    count_day_of_week[i%7+1]+=1\n end\n\n\n\n\nCode\nS = sum_n ./ count_day_of_week\n\n\n7-element Vector{Float64}:\n -0.0458947770756838\n -0.48588728064630987\n  0.055816830757215156\n  0.18126518762346477\n  0.1879316238881742\n  0.1451808639178051\n  0.15539502298303573\n\n\n\n\nCode\nDates.dayname(Date(df.Date[40], dateformat\"y/m/d\"))\n\n\n\"Monday\"\n\n\n40番目のデータに対応する曜日は月曜日なのでSの1番目は日曜日に対応する.\n\n\nCode\ndow=[Dates.dayname(Date(df.Date[40+i], dateformat\"y/m/d\")) for i=-1:5];\n\n\n\n\nCode\nplot(dow,S,seriestype = :bar)\n\n\n\n\n\n上図からも確かに曜日別の影響として月曜が少なく, 木曜が大きくでる傾向がわかる.\n最後にI_tを計算してみる.\n\n\nCode\nI=zeros(length(df.ALL)-39)\nfor (i,n) in enumerate((df.log_diff )[40:end])\n    I[i]=n-S[i%7+1]\nend\n\n\n\n\nCode\nplot(I, seriestype = :scatter)\n\n\n\n\n\n以上がTC_tとして移動平均を採用した場合の結果である. I_tは流行と曜日の影響を除外したものであることを期待しているが上図からは明らかにそれらが除外できていないことがわかる. 実際山が5つある.\n\n\nCode\nplot(df.Date[40:end], df.log_all[40:end], seriestype = :scatter)\nplot!(I, seriestype = :scatter)\n\n\n\n\n\nlog(y_t)とI_tを並べてみると位相のずれた波と似た挙動をしていることがわかる. すなわちコロナのデータに対しTC_tとして移動平均は適していない."
  },
  {
    "objectID": "posts/2022-01-04-covid.html#対数と線形回帰",
    "href": "posts/2022-01-04-covid.html#対数と線形回帰",
    "title": "Covid in Japan",
    "section": "4.3 対数と線形回帰",
    "text": "4.3 対数と線形回帰\n次はTC_tとして各流行を線形回帰したものを採用してみる.\n\n4.3.1 区間の計算\nまずは流行の区間を計算する. (以下では流行の山と谷を計算しようとしているが上手に計算できなかった. 連続関数なら1階微分が0となる点を求めるが今のデータの場合このアイデアではうまく求めることができなかった. 代わりに全期間から最大の位置を求め, 順に適当な区間で最大最小を交互に計算した. それでも上手に計算できなかったので最後は目視で区間を設定した.)\n\n\nCode\nfunction minima(array,i,r)\n    res=i-r+findmin(array[max(i-r,1):i])[2]\n    while res!=i\n        i=res\n        res=i-r+findmin(array[max(i-r,1):i])[2]\n    end\n    return res\nend\n\n\nminima (generic function with 1 method)\n\n\n\n\nCode\nfunction maxima(array,i,r)\n    res=i-r+findmax(array[max(i-r,1):i])[2]\n    while res!=i\n        i=res\n        res=i-r+findmax(array[max(i-r,1):i])[2]\n    end\n    return res\nend\n\n\nmaxima (generic function with 1 method)\n\n\n\n\nCode\nfunction extremes(array,r)\n    i_max=findmax(array)[2]\n    res=[i_max]\n    i=i_max\n    i_min=1\n    while i-r>0 && i !=i_min\n        i_min=minima(array,i_max,r)\n        println(i,\" \",i_min)\n        i_max=maxima(array,i_min,r)\n        push!(res,i_min)\n        push!(res,i_max)\n        i=i_min\n    end\n    return res\nend\n    \n\n\nextremes (generic function with 1 method)\n\n\n\n\nCode\nperiod=extremes(df.ALL, 20)\nappend!(period,extremes(df.ALL[1:480], 15))\nunique!(period)\npush!(period,minima(df.ALL,450,10))\nappend!(period,[30,90,140,680,length(df.ALL)])\nsort!(period)\n\n\n947 888\n359 253\n\n\n12-element Vector{Int64}:\n   30\n   90\n  140\n  206\n  253\n  359\n  419\n  680\n  847\n  888\n  947\n 1090\n\n\n\n\nCode\nplot(df.Date, df.weekly_ave,seriestype = :scatter)\nvline!(period)\n\n\n\n\n\n\n\nCode\nplot(df.Date, df.log_all, seriestype = :scatter)\nvline!(period)\n\n\n\n\n\n\n\n4.3.2 線形回帰\n最初の流行について対数の世界で線形回帰してみる. 回帰にはGLMパッケージを利用する.\n\n\nCode\nplot(period[1]:period[2],df.log_all[period[1]:period[2]], seriestype = :scatter)\n\n\n\n\n\n\n\nCode\ni=1\ndata = DataFrame(X=period[i]:period[i+1], Y=df.log_all[period[i]:period[i+1]])\nols = lm(@formula(Y ~ X), data)\n\n\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}\n\nY ~ 1 + X\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────────\n                  Coef.  Std. Error      t  Pr(>|t|)   Lower 95%   Upper 95%\n────────────────────────────────────────────────────────────────────────────\n(Intercept)  -0.807003   0.22738     -3.55    0.0008  -1.26199    -0.352016\nX             0.0789489  0.00363634  21.71    <1e-29   0.0716726   0.0862252\n────────────────────────────────────────────────────────────────────────────\n\n\n\n\nCode\nplot(period[i]:period[i+1]-1,df.log_all[period[i]:period[i+1]-1], seriestype = :scatter)\nplot!(data.X,predict(ols))\n\n\n\n\n\n同様に他の区間でも回帰する:\n\n\nCode\npred=predict(ols)\nfor i=2:length(period)-1\n    data = DataFrame(X=period[i]:period[i+1]-1, Y=df.log_all[period[i]:period[i+1]-1])\n    ols = lm(@formula(Y ~ X), data)\n    append!(pred,predict(ols))\nend\n\n\n\n\nCode\nplot(df.Date[period[1]:end], df.log_all[period[1]:end], seriestype = :scatter)\nplot!(df.Date[period[1]:end],pred,seriestype = :scatter)\n\n\n\n\n\nこれで各流行で回帰ができた.\nあとはこの回帰をTC_tとして先ほどと同じ手順でS_t, I_tを計算してみる.\n\n\nCode\ndiff= df.log_all[period[1]:end] .- pred;\n\n\n\n\nCode\nplot(diff, seriestype = :scatter)\n\n\n\n\n\n\n\nCode\nsum_n=zeros(7)\ncount_day_of_week=zeros(Int,7)\nfor (i, n) in enumerate(diff)\n    sum_n[i%7+1]+=n\n    count_day_of_week[i%7+1]+=1\n end\n\n\n\n\nCode\nS2 = sum_n ./ count_day_of_week\n\n\n7-element Vector{Float64}:\n  0.1597298156141544\n  0.1224051792494716\n  0.14164292461164305\n -0.07029766752689469\n -0.4973507234395729\n  0.03803188451298746\n  0.14337600662335104\n\n\n\n\nCode\nDates.dayname(Date(df.Date[period[1]], dateformat\"y/m/d\"))\n\n\n\"Friday\"\n\n\n\n\nCode\ndow=[Dates.dayname(Date(df.Date[period[1]+i], dateformat\"y/m/d\")) for i=-1:5];\n\n\n\n\nCode\nplot(dow,S2,seriestype = :bar)\n\n\n\n\n\n\n\nCode\nI2=zeros(length(df.ALL)-period[1]+1)\nfor (i,n) in enumerate((diff )[period[1]:end])\n    I2[i]=n-S2[i%7+1]\nend\n\n\n\n\nCode\nplot(I2, seriestype = :scatter)\n\n\n\n\n\n個人的な感覚ではこの結果からもまだ傾向のようなもの感じるがを移動平均を使った場合の結果と比べるとかなり改善はされた. コロナの新規陽性者のデータに対しTC_tとして安直に移動平均を使うのは不適切である."
  },
  {
    "objectID": "posts/computations.html",
    "href": "posts/computations.html",
    "title": "Quarto Computations",
    "section": "",
    "text": "array([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14]])"
  },
  {
    "objectID": "posts/computations.html#matplotlib",
    "href": "posts/computations.html#matplotlib",
    "title": "Quarto Computations",
    "section": "Matplotlib",
    "text": "Matplotlib"
  },
  {
    "objectID": "posts/computations.html#plotly",
    "href": "posts/computations.html#plotly",
    "title": "Quarto Computations",
    "section": "Plotly",
    "text": "Plotly"
  },
  {
    "objectID": "posts/Julia-demo.html",
    "href": "posts/Julia-demo.html",
    "title": "Plots Demo",
    "section": "",
    "text": "Code\nusing Pkg\n\n\n\n\nCode\nusing Plots\nPlots.gr(fmt = :png)\nplot(sin, \n     x->sin(2x), \n     0, \n     2π, \n     leg=false, \n     fill=(0,:lavender))\n\n\n\n\n\n\n\nCode\nPlots._current_plots_version\n\n\nv\"1.27.0\""
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "notebooks2",
    "section": "",
    "text": "Covid in Japan\n\n\n\n\n\n\n\n\n\n\n\n\nMasaya Kameyama\n\n\n\n\n\n\n\n\nQuarto Computations\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nPlots Demo\n\n\n\n\n\n\n\n\n\n\n\n\nMay 22, 2021\n\n\nNorah Jones\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]